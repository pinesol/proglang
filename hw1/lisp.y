%{
#include <iostream>

int yylex(); // A function that is to be generated and provided by flex,
             // which returns a next token when called repeatedly.
int yyerror(const char *p) { std::cerr << "error: " << p << std::endl; return 0;};
%}

%union {
    int val;
    /* You may include additional fields as you want. */
    /* char op; */
};

%start prog

%token LPAREN RPAREN
%token PLUS MINUS MUL DIV
%token <val> NUM    /* 'val' is the (only) field declared in %union
                       which represents the type of the token. */

%type <val> list expr plus_func

 /* TODO doesn't work! */

/* Resolve the ambiguity of the grammar by defining precedence. */

/* Order of directives will determine the precedence. */
%left PLUS MINUS    /* left means left-associativity. */
%left DIV MUL

%%

prog : list                             { std::cout << $1 << std::endl; }
     ;

list : LPAREN expr RPAREN               { $$ = $2; }

expr : PLUS plus_func                { $$ = $2; }
       /*
     | MINUS args { $$ = $$ - $2; }
     | MUL args { $$ = $$ * $2; }
     | DIV args { $$ = $$ / $2; }
       */
     ;

plus_func : list plus_func  { $$ = $$ + $1; }
          | NUM plus_func  { $$ = $$ + $1; }
          | NUM | list /* default action: { $$ = $1; } */
          ;


%%

int main()
{
    yyparse(); // A parsing function that will be generated by Bison.
    return 0;
}
